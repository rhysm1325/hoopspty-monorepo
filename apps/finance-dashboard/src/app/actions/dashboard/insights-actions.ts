'use server'

import { redirect } from 'next/navigation'
import { getUser } from '@/lib/auth/auth'
import { hasPermission } from '@/lib/auth/roles'
import { revenueStreamAnalytics } from '@/lib/analytics/revenue-streams'
import { financialCalculations } from '@/lib/analytics/calculations'
import { getCurrentFinancialYear } from '@/lib/utils/dates'
import { logAuditEvent } from '@/lib/audit/logger'
import { REVENUE_VARIANCE_THRESHOLD_PERCENT } from '@/constants/financial'
import type { RevenueStream } from '@/types'

export interface ActionResult<T = any> {
  success: boolean
  data?: T
  error?: string
  message?: string
}

export interface FinancialInsight {
  id: string
  type: 'positive' | 'negative' | 'neutral' | 'warning' | 'critical'
  category: 'revenue' | 'cash_flow' | 'collections' | 'payments' | 'margins' | 'working_capital' | 'general'
  priority: 'low' | 'medium' | 'high' | 'critical'
  title: string
  description: string
  impact: string
  recommendation?: string
  actionRequired: boolean
  actionItems?: string[]
  relatedMetrics: {
    current: number
    target?: number
    prior?: number
    variance?: number
    variancePercent?: number
  }
  trend: 'improving' | 'declining' | 'stable'
  confidence: 'low' | 'medium' | 'high'
  lastUpdated: Date
  expiresAt?: Date
}

export interface VarianceAlert {
  id: string
  metric: string
  category: string
  currentValue: number
  expectedValue: number
  variance: number
  variancePercent: number
  threshold: number
  severity: 'info' | 'warning' | 'critical'
  trend: 'improving' | 'declining' | 'stable'
  description: string
  recommendation: string
  autoGenerated: boolean
}

/**
 * Generate comprehensive financial insights and variance alerts
 */
export async function getFinancialInsightsAction(): Promise<ActionResult<{
  insights: FinancialInsight[]
  alerts: VarianceAlert[]
}>> {
  try {
    const user = await getUser()
    if (!user) {
      redirect('/login')
    }

    if (!hasPermission(user.role, 'canViewFinancials')) {
      return {
        success: false,
        error: 'You do not have permission to view financial insights',
      }
    }

    const currentFY = getCurrentFinancialYear()
    const insights: FinancialInsight[] = []
    const alerts: VarianceAlert[] = []

    // Get revenue performance alerts
    const revenueAlerts = await revenueStreamAnalytics.getPerformanceAlerts(currentFY.year)
    
    revenueAlerts.forEach(alert => {
      const insight: FinancialInsight = {
        id: `revenue_${alert.revenue_stream}`,
        type: alert.alert_type === 'positive' ? 'positive' : alert.alert_type === 'negative' ? 'warning' : 'neutral',
        category: 'revenue',
        priority: alert.severity,
        title: `${alert.revenue_stream.charAt(0).toUpperCase() + alert.revenue_stream.slice(1)} Revenue ${alert.alert_type === 'positive' ? 'Growth' : 'Decline'}`,
        description: alert.message,
        impact: `${Math.abs(alert.variance_percent).toFixed(1)}% variance vs prior year affecting overall revenue performance`,
        recommendation: alert.recommended_action,
        actionRequired: alert.severity === 'high',
        actionItems: alert.severity === 'high' ? [
          'Review revenue stream performance drivers',
          'Analyze customer behavior changes',
          'Adjust marketing and sales strategies'
        ] : undefined,
        relatedMetrics: {
          current: 0, // Would be populated with actual revenue data
          variancePercent: alert.variance_percent,
        },
        trend: alert.variance_percent > 0 ? 'improving' : 'declining',
        confidence: 'high',
        lastUpdated: new Date(),
      }
      
      insights.push(insight)
    })

    // Get cash flow metrics for insights
    const cashFlowMetrics = await financialCalculations.calculateCashFlowMetrics()
    
    // Cash conversion cycle insights
    if (cashFlowMetrics.cash_conversion_cycle < -5) {
      insights.push({
        id: 'cash_cycle_positive',
        type: 'positive',
        category: 'cash_flow',
        priority: 'medium',
        title: 'Excellent Cash Conversion Cycle',
        description: `Negative cash conversion cycle of ${cashFlowMetrics.cash_conversion_cycle.toFixed(1)} days generates positive cash flow`,
        impact: 'Business collects cash before paying suppliers, improving working capital efficiency',
        recommendation: 'Maintain current collection and payment practices to preserve this competitive advantage',
        actionRequired: false,
        relatedMetrics: {
          current: cashFlowMetrics.cash_conversion_cycle,
          target: -10.0,
          variance: cashFlowMetrics.cash_conversion_cycle - (-10.0),
        },
        trend: 'stable',
        confidence: 'high',
        lastUpdated: new Date(),
      })
    }

    // DSO insights
    if (cashFlowMetrics.dso > 20) {
      insights.push({
        id: 'dso_warning',
        type: 'warning',
        category: 'collections',
        priority: 'high',
        title: 'DSO Above Target Threshold',
        description: `Days Sales Outstanding of ${cashFlowMetrics.dso.toFixed(1)} days exceeds healthy levels`,
        impact: `Approximately ${formatCurrency(cashFlowMetrics.ar_total * 0.3)} tied up in slow-moving receivables`,
        recommendation: 'Implement aggressive collection procedures and review credit policies',
        actionRequired: true,
        actionItems: [
          'Contact all customers >45 days overdue',
          'Review and tighten credit approval process',
          'Consider offering early payment discounts',
          'Implement automated payment reminders'
        ],
        relatedMetrics: {
          current: cashFlowMetrics.dso,
          target: 15.0,
          variance: cashFlowMetrics.dso - 15.0,
          variancePercent: ((cashFlowMetrics.dso - 15.0) / 15.0) * 100,
        },
        trend: 'declining',
        confidence: 'high',
        lastUpdated: new Date(),
      })
    }

    // Get overdue customers for insights
    const overdueCustomers = await financialCalculations.getOverdueCustomers()
    
    if (overdueCustomers.length > 0) {
      const totalOverdue = overdueCustomers.reduce((sum, customer) => sum + customer.total_outstanding, 0)
      const criticalCustomers = overdueCustomers.filter(c => c.oldest_invoice_days > 90)
      
      if (criticalCustomers.length > 0) {
        insights.push({
          id: 'critical_customers',
          type: 'critical',
          category: 'collections',
          priority: 'critical',
          title: 'Critical Collection Issues',
          description: `${criticalCustomers.length} customers with invoices >90 days overdue`,
          impact: `${formatCurrency(criticalCustomers.reduce((sum, c) => sum + c.total_outstanding, 0))} at risk of becoming bad debt`,
          recommendation: 'Immediate collection action required to prevent write-offs',
          actionRequired: true,
          actionItems: [
            'Contact critical customers immediately',
            'Consider collection agency for non-responsive accounts',
            'Review credit limits and terms',
            'Implement payment plans where appropriate'
          ],
          relatedMetrics: {
            current: criticalCustomers.length,
            target: 0,
            variance: criticalCustomers.length,
          },
          trend: 'declining',
          confidence: 'high',
          lastUpdated: new Date(),
        })
      }
    }

    // Get overdue suppliers for insights
    const overdueSuppliers = await financialCalculations.getOverdueSuppliers()
    
    if (overdueSuppliers.length > 0) {
      const strategicOverdue = overdueSuppliers.filter(s => 
        s.contact_name.toLowerCase().includes('strategic') || 
        s.total_outstanding > 10000
      )
      
      if (strategicOverdue.length > 0) {
        insights.push({
          id: 'strategic_suppliers',
          type: 'critical',
          category: 'payments',
          priority: 'critical',
          title: 'Strategic Supplier Payment Risk',
          description: `${strategicOverdue.length} strategic suppliers have overdue payments`,
          impact: 'Risk of damaging critical supplier relationships and service disruption',
          recommendation: 'Prioritize payments to strategic suppliers immediately',
          actionRequired: true,
          actionItems: [
            'Process payments for strategic suppliers today',
            'Contact suppliers to explain any delays',
            'Review payment approval workflows',
            'Consider supplier financing options'
          ],
          relatedMetrics: {
            current: strategicOverdue.reduce((sum, s) => sum + s.total_outstanding, 0),
            target: 0,
          },
          trend: 'declining',
          confidence: 'high',
          lastUpdated: new Date(),
        })
      }
    }

    // Generate variance alerts for key metrics
    const currentMetrics = {
      cashPosition: 284295,
      arOutstanding: cashFlowMetrics.ar_total,
      apOutstanding: cashFlowMetrics.ap_total,
      dso: cashFlowMetrics.dso,
      dpo: cashFlowMetrics.dpo,
    }

    const expectedMetrics = {
      cashPosition: 250000,
      arOutstanding: 35000,
      apOutstanding: 25000,
      dso: 15.0,
      dpo: 30.0,
    }

    Object.entries(currentMetrics).forEach(([metric, current]) => {
      const expected = expectedMetrics[metric as keyof typeof expectedMetrics]
      const variance = current - expected
      const variancePercent = expected > 0 ? (variance / expected) * 100 : 0
      
      // Define thresholds for each metric
      const thresholds = {
        cashPosition: 15.0,
        arOutstanding: 20.0,
        apOutstanding: 25.0,
        dso: 25.0,
        dpo: 20.0,
      }
      
      const threshold = thresholds[metric as keyof typeof thresholds]
      
      if (Math.abs(variancePercent) > threshold) {
        alerts.push({
          id: `alert_${metric}`,
          metric: metric.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()),
          category: metric.includes('cash') ? 'cash_flow' : 
                   metric.includes('ar') ? 'collections' : 
                   metric.includes('ap') ? 'payments' : 'working_capital',
          currentValue: current,
          expectedValue: expected,
          variance,
          variancePercent,
          threshold,
          severity: Math.abs(variancePercent) > threshold * 2 ? 'critical' : 
                   Math.abs(variancePercent) > threshold ? 'warning' : 'info',
          trend: variance > 0 ? 'declining' : 'improving',
          description: `${metric.replace(/([A-Z])/g, ' $1')} is ${Math.abs(variancePercent).toFixed(1)}% ${variance > 0 ? 'above' : 'below'} expected levels`,
          recommendation: variance > 0 ? 
            'Monitor closely and consider corrective actions' : 
            'Performance is better than expected - maintain current practices',
          autoGenerated: true,
        })
      }
    })

    // Sort insights by priority and type
    insights.sort((a, b) => {
      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 }
      const typeOrder = { critical: 5, negative: 4, warning: 3, positive: 2, neutral: 1 }
      
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority]
      if (priorityDiff !== 0) return priorityDiff
      
      return typeOrder[b.type] - typeOrder[a.type]
    })

    // Sort alerts by severity
    alerts.sort((a, b) => {
      const severityOrder = { critical: 3, warning: 2, info: 1 }
      return severityOrder[b.severity] - severityOrder[a.severity]
    })

    // Log insights access
    await logAuditEvent({
      userId: user.id,
      action: 'insights_accessed',
      resourceType: 'financial_insights',
      resourceId: 'dashboard_view',
      details: {
        insightCount: insights.length,
        alertCount: alerts.length,
        criticalInsights: insights.filter(i => i.priority === 'critical').length,
        criticalAlerts: alerts.filter(a => a.severity === 'critical').length,
        actionRequiredCount: insights.filter(i => i.actionRequired).length,
        accessedAt: new Date(),
      },
      ipAddress: null,
    })

    return {
      success: true,
      data: { insights, alerts },
      message: `Generated ${insights.length} insights and ${alerts.length} variance alerts`,
    }
  } catch (error) {
    console.error('Financial insights error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to generate financial insights',
    }
  }
}

/**
 * Mark insight as acknowledged or acted upon
 */
export async function acknowledgeInsightAction(
  insightId: string,
  action: 'acknowledged' | 'acted_upon' | 'dismissed'
): Promise<ActionResult> {
  try {
    const user = await getUser()
    if (!user) {
      redirect('/login')
    }

    if (!hasPermission(user.role, 'canManageFinancials')) {
      return {
        success: false,
        error: 'You do not have permission to manage financial insights',
      }
    }

    // In real implementation, would update insight status in database
    // For now, just log the action
    
    await logAuditEvent({
      userId: user.id,
      action: 'insight_acknowledged',
      resourceType: 'financial_insight',
      resourceId: insightId,
      details: {
        action,
        acknowledgedAt: new Date(),
        acknowledgedBy: user.email,
      },
      ipAddress: null,
    })

    return {
      success: true,
      message: `Insight ${action.replace('_', ' ')} successfully`,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to acknowledge insight',
    }
  }
}

/**
 * Get insights filtered by category and priority
 */
export async function getFilteredInsightsAction(
  category?: string,
  priority?: string,
  actionRequiredOnly?: boolean
): Promise<ActionResult<FinancialInsight[]>> {
  try {
    const user = await getUser()
    if (!user) {
      redirect('/login')
    }

    if (!hasPermission(user.role, 'canViewFinancials')) {
      return {
        success: false,
        error: 'You do not have permission to view financial insights',
      }
    }

    // Get all insights first
    const allInsightsResult = await getFinancialInsightsAction()
    
    if (!allInsightsResult.success || !allInsightsResult.data) {
      return {
        success: false,
        error: 'Failed to load insights for filtering',
      }
    }

    let filteredInsights = allInsightsResult.data.insights

    // Apply filters
    if (category && category !== 'all') {
      filteredInsights = filteredInsights.filter(insight => insight.category === category)
    }

    if (priority && priority !== 'all') {
      filteredInsights = filteredInsights.filter(insight => insight.priority === priority)
    }

    if (actionRequiredOnly) {
      filteredInsights = filteredInsights.filter(insight => insight.actionRequired)
    }

    return {
      success: true,
      data: filteredInsights,
      message: `Found ${filteredInsights.length} insights matching filters`,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to filter insights',
    }
  }
}

// Helper function to format currency in server actions
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-AU', {
    style: 'currency',
    currency: 'AUD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount)
}
